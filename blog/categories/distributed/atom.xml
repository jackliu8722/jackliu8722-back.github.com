<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[博客分类: 分布式 | 精神兵的 Blog]]></title>
  <link href="http://jackliu8722.github.com/blog/categories/distributed/atom.xml" rel="self"/>
  <link href="http://jackliu8722.github.com/"/>
  <updated>2013-10-12T22:35:34+08:00</updated>
  <id>http://jackliu8722.github.com/</id>
  <author>
    <name><![CDATA[jackliu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Zookeeper-源码分析(二)——Server启动流程]]></title>
    <link href="http://jackliu8722.github.com/blog/2013/10/11/zookeeper-yuan-ma-fen-xi-02-serverqi-dong-liu-cheng/"/>
    <updated>2013-10-11T22:59:00+08:00</updated>
    <id>http://jackliu8722.github.com/blog/2013/10/11/zookeeper-yuan-ma-fen-xi-02-serverqi-dong-liu-cheng</id>
    <content type="html"><![CDATA[<p>Zookeeper中，server的启动入口为类org.apache.zookeeper.server.quorum.QuorumPeerMain的main方法，由zkServer.sh脚本调用。其main方法的内容如下：</p>

<p>{% codeblock lang:java %}</p>

<pre><code>public static void main(String[] args) {

    QuorumPeerMain main = new QuorumPeerMain();
    try {
        main.initializeAndRun(args);
    } catch (IllegalArgumentException e) {
        LOG.error("Invalid arguments, exiting abnormally", e);
        LOG.info(USAGE);
        System.err.println(USAGE);
        System.exit(2);
    } catch (ConfigException e) {
        LOG.error("Invalid config, exiting abnormally", e);
        System.err.println("Invalid config, exiting abnormally");
        System.exit(2);
    } catch (Exception e) {
        LOG.error("Unexpected exception, exiting abnormally", e);
        System.exit(1);
    }
    LOG.info("Exiting normally");
    System.exit(0);
}
</code></pre>

<p>{% endcodeblock%}</p>

<p>在main方法，调用了类QuorumPeerMain的initializeAndRun方法做后续的处理，其源码如下：</p>

<p>{% codeblock lang:java %}</p>

<pre><code>protected void initializeAndRun(String[] args)
    throws ConfigException, IOException
{    
    //创建配置类
    QuorumPeerConfig config = new QuorumPeerConfig();
    //如果只有一个参数，则调用配置类的parse方法解析配置文件
    if (args.length == 1) {
        config.parse(args[0]);
    }

    // 启动并调度清理任务，定时清理数据目录下的数据
    DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config
            .getDataDir(), config.getDataLogDir(), config
            .getSnapRetainCount(), config.getPurgeInterval());
    purgeMgr.start();
    //运行quorum模式
    if (args.length == 1 &amp;&amp; config.servers.size() &gt; 0) {
        runFromConfig(config);
    } else {
        //无配置文件，或者服务的数量为0，运行standalone模式
        LOG.warn("Either no config or no quorum defined in config, running "
                + " in standalone mode");
        // there is only server in the quorum -- run as standalone
        ZooKeeperServerMain.main(args);
    }
}
</code></pre>

<p>{%endcodeblock%}</p>

<p>在initializedAndRun方法中，zookeeper首先创建QuorumPeerConfig类解析配置文件，然后根据配置是否存在和server的数量选择运行的模式。如果无配置文件或者server的数量为1(即只有当前server)，则运行standalone模式，即代码中执行ZookeeperServerMain.main(args),否则以quorum模式运行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zookeeper-源码分析(一)——简介]]></title>
    <link href="http://jackliu8722.github.com/blog/2013/10/09/zookeeper-yuan-ma-fen-xi-01-jian-jie/"/>
    <updated>2013-10-09T23:10:00+08:00</updated>
    <id>http://jackliu8722.github.com/blog/2013/10/09/zookeeper-yuan-ma-fen-xi-01-jian-jie</id>
    <content type="html"><![CDATA[<h2>Zookeeper是什么</h2>

<p>Zookeeper是Hadoop的一个子项目，它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：维护配置信息(maintaining configuration information)、名字服务(naming service)、分布式同步(distributed synchronization)、组服务(group services)等等，以上的服务经常应用在分布式系统当中。</p>

<p>Zookeeper的目标是封装好复杂并易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户，从而降低用户实现分布式系统的难度。</p>
]]></content>
  </entry>
  
</feed>
